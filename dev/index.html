<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · UMAP.jl Documentation</title><meta name="title" content="Home · UMAP.jl Documentation"/><meta property="og:title" content="Home · UMAP.jl Documentation"/><meta property="twitter:title" content="Home · UMAP.jl Documentation"/><meta name="description" content="Documentation for UMAP.jl Documentation."/><meta property="og:description" content="Documentation for UMAP.jl Documentation."/><meta property="twitter:description" content="Documentation for UMAP.jl Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>UMAP.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#What-is-UMAP?"><span>What is UMAP?</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Design-and-Architecture"><span>Design and Architecture</span></a></li><li><a class="tocitem" href="#Key-Type-Abstractions"><span>Key Type Abstractions</span></a></li><li><a class="tocitem" href="#Core-Functions-by-Stage"><span>Core Functions by Stage</span></a></li><li><a class="tocitem" href="#High-Level-API-Functions"><span>High-Level API Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Multi-View-Data"><span>Multi-View Data</span></a></li><li><a class="tocitem" href="#Performance-Considerations"><span>Performance Considerations</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/mnist/">MNIST</a></li><li><a class="tocitem" href="examples/fashion_mnist/">Fashion MNIST</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="examples/advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="examples/composite/">Composite Views</a></li></ul></li><li><a class="tocitem" href="loss/">Loss Function</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="ref/public/">Public API</a></li><li><a class="tocitem" href="ref/internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dillondaudert/UMAP.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dillondaudert/UMAP.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="UMAP.jl-Documentation"><a class="docs-heading-anchor" href="#UMAP.jl-Documentation">UMAP.jl Documentation</a><a id="UMAP.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#UMAP.jl-Documentation" title="Permalink"></a></h1><p>Welcome to UMAP.jl, a pure Julia implementation of the Uniform Manifold Approximation and Projection (UMAP) algorithm for dimensionality reduction.</p><h2 id="What-is-UMAP?"><a class="docs-heading-anchor" href="#What-is-UMAP?">What is UMAP?</a><a id="What-is-UMAP?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-UMAP?" title="Permalink"></a></h2><p><strong>Uniform Manifold Approximation and Projection (UMAP)</strong> is an algorithm for transforming data on one (approximated) manifold and projecting it onto another. It is used for:</p><ul><li>Data visualization and dimensionality reduction</li><li>Preprocessing for machine learning</li><li>Nonlinear dimensionality reduction, similar to t-SNE</li><li>Theoretically motivated, computationally efficient</li></ul><p><a href="https://arxiv.org/abs/1802.03426">McInnes, L, Healy, J, UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction, ArXiv e-prints 1802.03426, 2018</a></p><h3 id="Algorithm-Overview"><a class="docs-heading-anchor" href="#Algorithm-Overview">Algorithm Overview</a><a id="Algorithm-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Overview" title="Permalink"></a></h3><p>UMAP operates under three key assumptions:</p><ol><li>The data is uniformly distributed on a Riemannian manifold (smooth, evenly sampled data)</li><li>The Riemannian metric is locally constant (we can use nearest neighbors to infer local geometry)</li><li>The manifold is locally connected (nearby points in high-dimensional space are also nearby on the manifold)</li></ol><p>Given data with some representation, the algorithm projects it into a new <strong>target</strong> manifold through:</p><ol><li><strong>Find nearest neighbors</strong> - locate approximate nearest neighbors for each point</li><li><strong>Construct fuzzy simplicial sets</strong> - build a weighted undirected graph representing the topological structure</li><li><strong>Initialize and optimize target embedding</strong> - create initial positions and refine via stochastic gradient descent</li></ol><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">using UMAP
using Distances

# Embed data into n_components dimensions
result = UMAP.fit(data, n_components; n_neighbors=15, metric=Euclidean())
embedding = result.embedding

# Transform new data using the fitted model
transform_result = UMAP.transform(result, new_data)
new_embedding = transform_result.embedding</code></pre><h2 id="Design-and-Architecture"><a class="docs-heading-anchor" href="#Design-and-Architecture">Design and Architecture</a><a id="Design-and-Architecture-1"></a><a class="docs-heading-anchor-permalink" href="#Design-and-Architecture" title="Permalink"></a></h2><p>UMAP.jl v0.2 is designed with two primary goals:</p><ol><li><strong>Generality</strong> - Support multiple views of input data and various target manifolds</li><li><strong>Extensibility</strong> - Enable future functionality without major refactors</li></ol><p>This section provides a comprehensive mental model of the UMAP.jl codebase, documenting key abstractions and how they fit together.</p><h3 id="Core-Pipeline"><a class="docs-heading-anchor" href="#Core-Pipeline">Core Pipeline</a><a id="Core-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Pipeline" title="Permalink"></a></h3><p>The UMAP algorithm flows through four main stages:</p><ol><li><strong>K-Nearest Neighbors Search</strong> → finds approximate nearest neighbors for each point</li><li><strong>Fuzzy Simplicial Set Construction</strong> → builds a topological representation of the data</li><li><strong>Embedding Initialization</strong> → creates initial positions in the target space</li><li><strong>Embedding Optimization</strong> → refines the embedding via gradient descent</li></ol><h2 id="Key-Type-Abstractions"><a class="docs-heading-anchor" href="#Key-Type-Abstractions">Key Type Abstractions</a><a id="Key-Type-Abstractions-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Type-Abstractions" title="Permalink"></a></h2><h3 id="Configuration-Types"><a class="docs-heading-anchor" href="#Configuration-Types">Configuration Types</a><a id="Configuration-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-Types" title="Permalink"></a></h3><p>The algorithm is parameterized by five categories of configuration:</p><h4 id="1.-Neighbor-Search-Parameters-(NeighborParams)"><a class="docs-heading-anchor" href="#1.-Neighbor-Search-Parameters-(NeighborParams)">1. Neighbor Search Parameters (<code>NeighborParams</code>)</a><a id="1.-Neighbor-Search-Parameters-(NeighborParams)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Neighbor-Search-Parameters-(NeighborParams)" title="Permalink"></a></h4><p>Abstract base type with two concrete implementations:</p><ul><li><p><strong><code>DescentNeighbors{M, K}</code></strong>: Uses approximate nearest neighbor search via NearestNeighborDescent</p><ul><li>Fields: <code>n_neighbors::Int</code>, <code>metric::M</code>, <code>kwargs::K</code></li></ul></li><li><p><strong><code>PrecomputedNeighbors{M}</code></strong>: Uses precomputed distances or KNN graphs</p><ul><li>Fields: <code>n_neighbors::Int</code>, <code>dists_or_graph::M</code></li></ul></li></ul><p><strong>Extensibility</strong>: Define new neighbor search methods by:</p><ol><li>Creating a subtype <code>T &lt;: NeighborParams</code></li><li>Implementing <code>knn_search(data, knn_params::T)</code> to return nearest neighbors</li></ol><p>Example from the implementation:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    knn_search(data, knn_params::DescentNeighbors) -&gt; (knns, dists)

Find approximate nearest neighbors using nndescent.
&quot;&quot;&quot;
function knn_search(data, knn_params::DescentNeighbors)
    knn_graph = NND.nndescent(data,
                              knn_params.n_neighbors,
                              knn_params.metric;
                              knn_params.kwargs...)
    return NND.knn_matrices(knn_graph)
end</code></pre><h4 id="2.-Source-(Input-Space)-Parameters"><a class="docs-heading-anchor" href="#2.-Source-(Input-Space)-Parameters">2. Source (Input Space) Parameters</a><a id="2.-Source-(Input-Space)-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Source-(Input-Space)-Parameters" title="Permalink"></a></h4><ul><li><p><strong><code>SourceViewParams{T&lt;:Real}</code></strong>: Controls fuzzy simplicial set construction per data view</p><ul><li><code>set_operation_ratio::T</code> — blend between union (1.0) and intersection (0.0)</li><li><code>local_connectivity::T</code> — number of neighbors assumed locally connected</li><li><code>bandwidth::T</code> — bandwidth for smooth k-distance calculation</li></ul></li><li><p><strong><code>SourceGlobalParams{T&lt;:Real}</code></strong>: Controls merging of multiple views</p><ul><li><code>mix_ratio::T</code> — ratio for weighted intersection of views</li></ul></li></ul><h4 id="3.-Target-(Embedding-Space)-Parameters"><a class="docs-heading-anchor" href="#3.-Target-(Embedding-Space)-Parameters">3. Target (Embedding Space) Parameters</a><a id="3.-Target-(Embedding-Space)-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Target-(Embedding-Space)-Parameters" title="Permalink"></a></h4><ul><li><p><strong><code>TargetParams{M, D, I, P}</code></strong>: Controls the embedding space</p><ul><li><code>manifold::M</code> — target manifold (typically <code>_EuclideanManifold{N}</code>)</li><li><code>metric::D</code> — distance metric (e.g., <code>SqEuclidean()</code>, <code>Euclidean()</code>)</li><li><code>init::I</code> — initialization method</li><li><code>memb_params::P</code> — membership function parameters</li></ul></li><li><p><strong><code>MembershipFnParams{T&lt;:Real}</code></strong>: Parameters for the target membership function</p><ul><li><code>min_dist::T</code> — minimum spacing in embedding</li><li><code>spread::T</code> — effective scale of embedded points</li><li><code>a::T</code>, <code>b::T</code> — curve fitting parameters (computed from min_dist/spread if not provided)</li></ul></li><li><p><strong><code>AbstractInitialization</code></strong>: Base type for initialization methods</p><ul><li><code>SpectralInitialization</code> — uses spectral decomposition of graph Laplacian</li><li><code>UniformInitialization</code> — random uniform initialization</li></ul></li></ul><p><strong>Extensibility</strong>: Support new target manifolds and initializations by implementing methods for new combinations of manifold and initialization types.</p><p>Example:</p><pre><code class="language-julia hljs"># Randomly initialize in Euclidean space of dimension N
function initialize_embedding(
    umap_graph,
    ::_EuclideanManifold{N},
    ::UniformInitialization
) where N
    return [20 .* rand(T, N) .- 10 for _ in 1:size(umap_graph, 2)]
end</code></pre><h4 id="4.-Optimization-Parameters"><a class="docs-heading-anchor" href="#4.-Optimization-Parameters">4. Optimization Parameters</a><a id="4.-Optimization-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Optimization-Parameters" title="Permalink"></a></h4><ul><li><strong><code>OptimizationParams</code></strong>: Controls stochastic gradient descent<ul><li><code>n_epochs::Int</code> — number of optimization epochs</li><li><code>lr::Float64</code> — initial learning rate</li><li><code>repulsion_strength::Float64</code> — weighting of negative samples</li><li><code>neg_sample_rate::Int</code> — number of negative samples per positive sample</li></ul></li></ul><h4 id="5.-Complete-Configuration"><a class="docs-heading-anchor" href="#5.-Complete-Configuration">5. Complete Configuration</a><a id="5.-Complete-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Complete-Configuration" title="Permalink"></a></h4><ul><li><strong><code>UMAPConfig{K, S, G, T, O}</code></strong>: Bundles all parameters together<ul><li>Fields: <code>knn_params</code>, <code>src_params</code>, <code>gbl_params</code>, <code>tgt_params</code>, <code>opt_params</code></li></ul></li></ul><h3 id="Result-Types"><a class="docs-heading-anchor" href="#Result-Types">Result Types</a><a id="Result-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Types" title="Permalink"></a></h3><ul><li><p><strong><code>UMAPResult{DS, DT, C, K, F, G}</code></strong>: Complete result of fitting UMAP</p><ul><li><code>data::DS</code> — original data</li><li><code>embedding::DT</code> — computed embedding</li><li><code>config::C</code> — configuration used</li><li><code>knns_dists::K</code> — k-nearest neighbors and distances</li><li><code>fs_sets::F</code> — fuzzy simplicial sets (per view)</li><li><code>graph::G</code> — final UMAP graph (coalesced views)</li></ul></li><li><p><strong><code>UMAPTransformResult{DS, DT, K, F, G}</code></strong>: Result of transforming new data</p><ul><li>Similar structure but without config (uses existing config from fit)</li></ul></li></ul><h2 id="Core-Functions-by-Stage"><a class="docs-heading-anchor" href="#Core-Functions-by-Stage">Core Functions by Stage</a><a id="Core-Functions-by-Stage-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions-by-Stage" title="Permalink"></a></h2><h3 id="Stage-1:-K-Nearest-Neighbors-Search"><a class="docs-heading-anchor" href="#Stage-1:-K-Nearest-Neighbors-Search">Stage 1: K-Nearest Neighbors Search</a><a id="Stage-1:-K-Nearest-Neighbors-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-1:-K-Nearest-Neighbors-Search" title="Permalink"></a></h3><p><strong><code>knn_search(data, knn_params) -&gt; (knns, dists)</code></strong></p><p>Dispatches based on <code>knn_params</code> type:</p><ul><li>For <code>DescentNeighbors</code>: calls <code>nndescent()</code> from NearestNeighborDescent.jl</li><li>For <code>PrecomputedNeighbors</code>: extracts from precomputed graph or constructs from distance matrix via <code>_knn_from_dists()</code></li></ul><p><strong>Multi-view support</strong>: When <code>data</code> and <code>knn_params</code> are <code>NamedTuple</code>s, maps <code>knn_search</code> over each view.</p><p><strong>Transform variant</strong>: <code>knn_search(data, queries, knn_params, result_knns_dists)</code> searches for neighbors of new queries in existing data.</p><h3 id="Stage-2:-Fuzzy-Simplicial-Set-Construction"><a class="docs-heading-anchor" href="#Stage-2:-Fuzzy-Simplicial-Set-Construction">Stage 2: Fuzzy Simplicial Set Construction</a><a id="Stage-2:-Fuzzy-Simplicial-Set-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-2:-Fuzzy-Simplicial-Set-Construction" title="Permalink"></a></h3><p><strong><code>fuzzy_simplicial_set(knns_dists, knn_params, src_params) -&gt; SparseMatrixCSC</code></strong></p><p>Converts k-nearest neighbor graph to fuzzy simplicial set (weighted graph). The elements are edges (v, w), each with a membership probability (edge weight) p(v, w).</p><p>For each view:</p><ol><li>Each point has a local simplicial set, representing the local notion of distance on the manifold (defined via distances to its knn)</li><li>We combine these via fuzzy set union/intersection to create the global graph</li></ol><p>The process:</p><ol><li><p><strong><code>smooth_knn_dists(dists, k, src_params) -&gt; (ρs, σs)</code></strong></p><ul><li>Computes smooth approximations to k-nearest neighbor distances</li><li><code>ρs</code>: distances to nearest neighbors (with local connectivity interpolation)</li><li><code>σs</code>: normalizing distances (found via binary search to match target perplexity)</li></ul><p>Binary search finds <code>σ</code> such that <code>∑ exp(-max(d - ρ, 0)/σ) ≈ log₂(k) * bandwidth</code>, ensuring perplexity approximates <code>k</code>.</p></li><li><p><strong><code>compute_membership_strengths(knns, dists, σs, ρs) -&gt; (rows, cols, vals)</code></strong></p><ul><li>Converts distances to membership strengths: <code>exp(-max(d - ρ, 0) / σ)</code></li><li>Returns sparse matrix components</li></ul></li><li><p><strong><code>merge_local_simplicial_sets(local_fs_set, set_op_ratio) -&gt; SparseMatrixCSC</code></strong></p><ul><li>Combines local fuzzy simplicial sets via fuzzy set union/intersection</li><li><code>set_op_ratio</code> interpolates between pure union and pure intersection</li></ul></li></ol><p><strong>Multi-view support</strong>:</p><ul><li><code>fuzzy_simplicial_set</code> maps over multiple views when inputs are <code>NamedTuple</code>s</li><li><code>coalesce_views(view_fuzzy_sets, gbl_params)</code> merges multiple views using <code>general_simplicial_set_intersection()</code></li></ul><p>The graphs of each view are coalesced into a single UMAP graph. This graph is sparse since, for each point, we only have non-zero probability to its <code>k</code> nearest neighbors, giving O(nk) entries.</p><h3 id="Stage-3:-Embedding-Initialization"><a class="docs-heading-anchor" href="#Stage-3:-Embedding-Initialization">Stage 3: Embedding Initialization</a><a id="Stage-3:-Embedding-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-3:-Embedding-Initialization" title="Permalink"></a></h3><p><strong><code>initialize_embedding(umap_graph, tgt_params) -&gt; embedding</code></strong></p><p>Creates initial embedding, dispatching on manifold type and initialization method:</p><ul><li><p><strong><code>SpectralInitialization</code></strong>:</p><ul><li><code>spectral_layout(graph, embed_dim)</code> computes normalized graph Laplacian <code>L = I - D^(-1/2) * G * D^(-1/2)</code></li><li>Extracts 2nd through (embed_dim+1)th smallest eigenvectors via Arpack</li><li>Falls back to random initialization if spectral decomposition fails</li></ul></li><li><p><strong><code>UniformInitialization</code></strong>:</p><ul><li>Random uniform initialization in <code>[-10, 10]^N</code></li></ul></li></ul><p><strong>Transform variant</strong>: <code>initialize_embedding(ref_embedding, umap_graph, tgt_params)</code> initializes new points as weighted averages of reference embedding.</p><h3 id="Stage-4:-Embedding-Optimization"><a class="docs-heading-anchor" href="#Stage-4:-Embedding-Optimization">Stage 4: Embedding Optimization</a><a id="Stage-4:-Embedding-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-4:-Embedding-Optimization" title="Permalink"></a></h3><p><strong><code>optimize_embedding!(embedding, umap_graph, tgt_params, opt_params) -&gt; embedding</code></strong></p><p>Optimizes embedding via stochastic gradient descent with:</p><ul><li><strong>Attractive forces</strong>: for edges in <code>umap_graph</code>, pull points together</li><li><strong>Repulsive forces</strong>: for random negative samples, push points apart</li></ul><p>Core optimization loop in <code>_optimize_embedding!()</code>:</p><ul><li>For each edge <code>(i, j)</code> with weight <code>p</code>:<ul><li>Sample edge with probability <code>p</code></li><li>Compute distance and gradient using target metric</li><li>Apply attractive force: gradient ∝ <code>-a*b / (dist * (a + dist^(-b)))</code></li><li>Sample <code>neg_sample_rate</code> random points</li><li>Apply repulsive force: gradient ∝ <code>repulsion_strength*b / (a*dist^(b+1) + dist)</code></li></ul></li><li>Gradients clipped to <code>[-4, 4]</code></li><li>Learning rate decays linearly across epochs</li></ul><p>Computationally, this iterates over each non-zero edge in the graph and calculates both attractive and repulsive forces between vertices as a function of their distance in the target embedding, O(enkd), where d is the dimension of the target embedding and e is the number of epochs.</p><p><strong>Transform variant</strong>: <code>optimize_embedding!(embedding, ref_embedding, umap_graph, ...)</code> optimizes query embedding against fixed reference embedding.</p><p><strong>Membership function</strong>: <code>fit_ab(min_dist, spread)</code> fits smooth curve to approximate exponential decay, returning parameters <code>(a, b)</code> used in gradient computation.</p><h2 id="High-Level-API-Functions"><a class="docs-heading-anchor" href="#High-Level-API-Functions">High-Level API Functions</a><a id="High-Level-API-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-API-Functions" title="Permalink"></a></h2><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><p>The basic API is designed to be user-friendly with reasonable defaults:</p><pre><code class="language-julia hljs"># Embed single view into Euclidean space with dim `n_components`,
# controlling execution via keyword arguments
result = UMAP.fit(data, n_components; kwargs...)</code></pre><p>Important keyword arguments:</p><ul><li><code>n_neighbors</code>: Controls local neighborhood size. Larger values capture more global structure, smaller values preserve more local structure.</li><li><code>metric</code>: Distance metric from <code>Distances.jl</code> package (default: <code>Euclidean()</code>)</li><li><code>min_dist</code>: Controls minimum spacing in the embedding. Larger values spread points more evenly, smaller values preserve more local structure.</li></ul><h3 id="Advanced-Usage"><a class="docs-heading-anchor" href="#Advanced-Usage">Advanced Usage</a><a id="Advanced-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Usage" title="Permalink"></a></h3><p>The advanced API allows complete customization of each stage, multiple data views, etc:</p><pre><code class="language-julia hljs">result = UMAP.fit(data, knn_params, src_params, gbl_params, tgt_params, opt_params)</code></pre><p>Helper functions for constructing configuration structs:</p><ul><li><code>create_view_config(...)</code></li><li><code>create_config(...)</code></li></ul><p>See the <a href="https://dillondaudert.github.io/UMAP.jl/dev/examples/advanced_usage/">Advanced Usage</a> example notebook for details.</p><h3 id="fit(data,-n_components;-kwargs...)-UMAPResult"><a class="docs-heading-anchor" href="#fit(data,-n_components;-kwargs...)-UMAPResult">fit(data, n_components; kwargs...) -&gt; UMAPResult</a><a id="fit(data,-n_components;-kwargs...)-UMAPResult-1"></a><a class="docs-heading-anchor-permalink" href="#fit(data,-n_components;-kwargs...)-UMAPResult" title="Permalink"></a></h3><p>Main entry point. Creates configuration from kwargs, then calls pipeline:</p><pre><code class="language-julia hljs"># The generic fit algorithm - works for single and named tuples of configs
function fit(data, knn_params, src_params, gbl_params, tgt_params, opt_params)
    # 1. Find (approx) nearest neighbors
    knns_dists = knn_search(data, knn_params)
    # 2. Construct the umap graph (global fuzzy simplicial set)
    fs_sets = fuzzy_simplicial_set(knns_dists, knn_params, src_params)
    umap_graph = coalesce_views(fs_sets, gbl_params)
    # 3. Initialize the target embedding
    embedding = initialize_embedding(umap_graph, tgt_params)
    # 4. Optimize the embedding
    optimize_embedding!(embedding, umap_graph, tgt_params, opt_params)

    config = UMAPConfig(knn_params, src_params, gbl_params, tgt_params, opt_params)
    return UMAPResult(data, embedding, config, knns_dists, fs_sets, umap_graph)
end</code></pre><p>Returns <code>UMAPResult</code> containing all intermediate results.</p><h3 id="transform(result::UMAPResult,-queries;-kwargs...)-UMAPTransformResult"><a class="docs-heading-anchor" href="#transform(result::UMAPResult,-queries;-kwargs...)-UMAPTransformResult">transform(result::UMAPResult, queries; kwargs...) -&gt; UMAPTransformResult</a><a id="transform(result::UMAPResult,-queries;-kwargs...)-UMAPTransformResult-1"></a><a class="docs-heading-anchor-permalink" href="#transform(result::UMAPResult,-queries;-kwargs...)-UMAPTransformResult" title="Permalink"></a></h3><p>Embeds new queries using existing model:</p><pre><code class="language-julia hljs">knns_dists = knn_search(result.data, queries, knn_params, result.knns_dists)
fs_sets = fuzzy_simplicial_set(result.data, knns_dists, knn_params, src_params)
query_graph = coalesce_views(fs_sets, gbl_params)
query_embedding = initialize_embedding(query_graph, tgt_params)
optimize_embedding!(query_embedding, result.embedding, query_graph, tgt_params, opt_params)</code></pre><p>Note that the type of <code>new_data</code> must match the original <code>data</code> exactly. The parameterization used for <code>fit</code> is re-used where appropriate in <code>transform</code>, via the <code>UMAPResult</code> struct.</p><h3 id="Using-Precomputed-Distances"><a class="docs-heading-anchor" href="#Using-Precomputed-Distances">Using Precomputed Distances</a><a id="Using-Precomputed-Distances-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Precomputed-Distances" title="Permalink"></a></h3><p>UMAP can use a precomputed distance matrix instead of finding nearest neighbors itself:</p><pre><code class="language-julia hljs">result = UMAP.fit(distances, n_components; metric=:precomputed)</code></pre><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><h3 id="Fuzzy-Set-Operations"><a class="docs-heading-anchor" href="#Fuzzy-Set-Operations">Fuzzy Set Operations</a><a id="Fuzzy-Set-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Fuzzy-Set-Operations" title="Permalink"></a></h3><ul><li><strong><code>merge_local_simplicial_sets(fs_set, set_op_ratio)</code></strong>: Merges local sets via interpolation</li><li><strong><code>_fuzzy_set_union(fs_set)</code></strong>: <code>A ∪ B = A + B - A*B</code></li><li><strong><code>_fuzzy_set_intersection(fs_set)</code></strong>: <code>A ∩ B = A*B</code></li></ul><h3 id="Multi-View-Merging"><a class="docs-heading-anchor" href="#Multi-View-Merging">Multi-View Merging</a><a id="Multi-View-Merging-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-View-Merging" title="Permalink"></a></h3><ul><li><strong><code>general_simplicial_set_union(left, right)</code></strong>: Union of two global fuzzy sets</li><li><strong><code>general_simplicial_set_intersection(left, right, params)</code></strong>: Weighted intersection with mix ratio</li><li><strong><code>reset_local_connectivity(simplicial_set)</code></strong>: Rescales confidences to maintain local connectivity after merging</li></ul><h2 id="Multi-View-Data"><a class="docs-heading-anchor" href="#Multi-View-Data">Multi-View Data</a><a id="Multi-View-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-View-Data" title="Permalink"></a></h2><p>UMAP.jl supports data with multiple &quot;views&quot; - different representations of the same entities. A feature vector and its label, for example, or a retail product with both text description and image.</p><p>Data with multiple views can use different notions of distance for each representation:</p><ul><li>Vectors in ℝⁿ with Euclidean distance (e.g., images)</li><li>Strings with Levenshtein distance</li><li>Categories or labels</li></ul><p>Views are represented as <code>NamedTuple</code>s with consistent keys. Functions automatically map over views when inputs are <code>NamedTuple</code>s, and views are merged using <code>coalesce_views()</code> with configurable intersection strategy.</p><h2 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h2><h3 id="Memory-Usage"><a class="docs-heading-anchor" href="#Memory-Usage">Memory Usage</a><a id="Memory-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Usage" title="Permalink"></a></h3><p>The current design assumes that the UMAP graph and target embedding can fit in memory:</p><ul><li>The UMAP graph (sparse matrix) O(nk)</li><li>Embedding O(nd) for an embedding dimension of d</li></ul><p>The data itself may be larger than this, as long as the <code>knn_search</code> stage supports it properly, e.g., by precomputing nearest neighbors prior to calling into UMAP.</p><h3 id="Computational-Complexity"><a class="docs-heading-anchor" href="#Computational-Complexity">Computational Complexity</a><a id="Computational-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Complexity" title="Permalink"></a></h3><p>In general, runtime is dominated by embedding optimization. Each stage has its own general complexity:</p><ul><li><p><code>knn_search</code>: When using <code>nndescent</code>, empirical runtime is O(n^1.14)</p></li><li><p><code>fuzzy_simplicial_set</code>: Iterates over each point and its knn: O(nk)</p></li><li><p><code>optimize_embedding</code>: For each epoch e, we iterate over each point n</p><ul><li>Each neighbor with membership probability, fixed to be log₂(k)</li><li>For each point, sample γ points at random for repulsive force</li><li>For each attractive and repulsive force, calculate distance as function of target embedding d</li></ul><p>Giving complexity of approximately O(e · n · log₂(k) · γ · d)</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/mnist/">MNIST »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 15 January 2026 14:29">Thursday 15 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
